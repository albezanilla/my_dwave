# This utility reads a pickle file containing a QUBO which has been
# generated by either subqubo_deqo.py or subqbo_ocean.py and validates
# it.  After printing out a text representation of the QUBO, it then
# evaluates the QUBO for all possible assigments to the variables over
# which the QUBO has been defined.  The minimum and maximum value
# appearing for the valid states is printed.  These two values should
# be equal if the QUBO is properly generated.  The minimum value for
# the invalid states is also printed.  This should be greater than the
# objective value for the valid states if the QUBO is properly
# generated.

import pickle
import ii
import validate
from sympy import symbols
import sys

usage_message = 'Usage: val_check.py {deqo|ocean} {cube1|cube2|cube3|cube4|up|down|front|back}'

methods = {'deqo', 'ocean'}
subqubos = {'cube1', 'cube2', 'cube3', 'cube4', 'up', 'down', 'front', 'back'}

if len(sys.argv) == 3 and sys.argv[1] in methods and sys.argv[2] in subqubos:
    method = sys.argv[1]
    subqubo = sys.argv[2]

    filename = subqubo + '.' + method + '.pickle'
    
    try:
        with open(filename, 'rb') as f:
            qubo = pickle.load(f)
    except FileNotFoundError:
        print('error: file "%s" does not exist' % filename)
        sys.exit(1)

    if subqubo[0:4] == 'cube':
        cube_num = int(subqubo[4])
        logical_vars, valid_states = ii.cube_configurations(cube_num)
    else:
        logical_vars, valid_states = ii.face_configurations(subqubo[0])

    print('\n**************** QUBO generated by %s for %s ****************\n' % (method.upper(), subqubo))
    print(qubo)

    logical_syms = tuple(symbols(logical_vars))
    min_valid, max_valid, min_invalid = validate.check_qubo(logical_syms, valid_states, qubo)

    print('\n**************** Valid states ****************\n')
    print('minimum objective = %f ; maximum objective = %f' % (min_valid, max_valid))

    print('\n**************** Invalid states ****************\n')
    print('minimum objective = %f' % min_invalid)

else:
    print(usage_message)
    sys.exit(1)
